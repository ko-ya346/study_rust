# 経緯
- nifty では研修でSNS的なサービスやブログシステムを作るらしい
- 今後のキャリアを考えて習得しておきたい
- 飲み会で Rust の話が出たので学びたい
- 前に挫折したので何か作り切りたい

# 目標達成のために
- とりあえず簡単なAPI サーバー作る
--  hello world 返すだけ、みたいな

# 参考資料
https://doc.rust-jp.rs/book-ja/ch01-01-installation.html

## 4/26
```
# rustup をインストール
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

# パスを通す 
. "$HOME/.cargo/env"

rustc --version

# main.rs を用意
# コンパイル
rustc main.rs
# 実行
./main 
```

### Cargo 
- https://doc.rust-jp.rs/book-ja/ch01-03-hello-cargo.html
- Cargo は Rust のビルドシステム兼パッケージマネージャ
- コードのビルド、依存するライブラリのダウンロード、それらのビルドなどをする
- コードのパッケージを**クレート**と呼ぶ

```

# Cargo のバージョン確認
cargo --version

cd ..
cargo new hello_cargo
cd hello_cargo
cargo build
./target/debug/hello_cargo
```

## 4/27
### guessing_game
- Cargo.toml の [dependencies] の下に rand 追加
- `cargo build` 実行
- 取得していないものがあればダウンロードする
    - rand が動作するために依存している他のクレートも取り込まれる
- プロジェクトを初めてビルドするとき、Cargo は条件に合うすべての依存関係のバージョンを計算し Cargo.lock ファイルに書き込む
    - 再現性のあるビルドを自動的に行える
- クレートをアップデートしたいときは updateコマンドをつかう
    - Cargo.lock を無視して Cargo.toml ファイル内のすべての指定に適合する最新バージョンを算出
- クレート、トレイト、ライブラリ、メソッド、関数、enum あたりの用語を整理したい


- 変数 let, 定数 const
- x: `let mut spaces = "  "; spaces = spaces.len()`
- o: `let spaces = "  "; let spaces = spaces.len()`

- 演算子 (+, -, *, /, %)
- boolean true, false
- char (シングルクォート)
- タプル
    - 複数の型の何らかの値を一つの複合型にまとめあげる
    - `let tup; (i32, f64, u8) = (500, 6.4, 1);`
    - `let (x, y, z) = tup;` (分配)
    - `tup.0` とかでもアクセスできる
- 配列型
    - 複数の値のコレクションを得ることができる
    - 配列の全要素は同じ型出なければならない
    - `let a: [i32; 5] = [1, 2, 3, 4, 5];`
    - `let a = [3; 5];` でも初期化できる ([3,3,3,3,3])
    - ``

```
// 文は値を返さない、; で終わる
// 式は値を返す、    ; が付かない

let y = {
    let x = 1;
    x + 1
}
```

- 条件式は bool 型でならなければいけない

```
let condition = true;
// 結果となる可能性がある値は、同じ型でなければならない
let number = if condition { 5 } else { 6 };
```


### 所有権
- 各値は所有者と呼ばれる変数と対応
- いかなる時も所有者は一つ
- 所有者がスコープから外れたら、値は破棄される
- 整数のようなコンパイル時に既知のサイズを持つ型はスタック上に保持され、コピーも高速。なので有効
    - 型が Copy トレイトに適合していれば、代入後も古い変数が使用可能
    - あらゆる整数型、bool, あらゆる浮動小数点型, char, タプル(Copyの型だけ含む場合)
- 関数に値を渡すことと値を変数に代入することは似ている
    - 関数に変数を渡すと代入のようにムーブやコピーされる
- 参照として渡す方法 -> & つける
- 可変な参照は 1つしかもてない
- 可変な参照と不変な参照は共存できない
- 不変な参照をしている間は可変な参照ができない
- 複数の不変参照は可能
- 関数の返り値が借用だとエラー
    - ライフタイム
    - 終了時点でドロップされるので存在しないメモリを返すことになる
- スライス: 部分参照
    - String のスライス型は &str
    - 文字リテラルは &str
    - &String 引数は &str にして渡すと汎化性能上がる（String を &word[..] で渡す）
    - 配列にもスライスが存在する

## 4/29
- prac_struct
- prac_enum
- restaurant

### 構造体 
- 意味のあるグループを形成する複数の関連した値をまとめ、名前付けできる独自のデータ型
- 構造体に参照を保持させようとするとライフタイムを使う必要がある

### 列挙型 (enum)
- 代数的データ型に酷似している (F#, OCaml, Haskell)
- 取りうる値をすべて列挙できる
- それらの列挙子のいずれか一つにしかなりえない
- Rust には null 機能がない
- :: でその値にアクセス

## 4/29
- Option<> がよくわからんな
    - Some(T) みたいなやつとか

### 肥大化するプロジェクトを管理
- パッケージは複数のバイナリクレートからなる
- また、ライブラリクレートを1つ持てる
- パッケージ: クレートをビルドし、テストし、共有することができる Cargo の機能
- クレート: ライブラリか実行可能ファイルを生成する、木構造をしたモジュール群
    - クレートはバイナリかライブラリのどちらか
- モジュールと use: これを使うとパス構成、スコープ、公開有無を決定できる
    - クレート内のコードをグループ化し、可読性と再利用性を上げる
- パス: 要素に名前を付ける方法
- クレートルート: Rustコンパイラの開始点、クレートのルートモジュールを作るソースファイル
    - src/main.rs はパッケージと同じ名前を持つバイナリクレートのクレートルート
    - src/lib.rs はパッケージと同じ名前のライブラリクレートが含まれており、そのファイルをクレートルートだと Cargo が判断
 

## 4/30 
- prac_vec
- prac_string2
- prac_hashmap
- prac_error
- Display トレイトってなんだ？実装する型があるらしい
    - たぶん Option<T> についていない

## 5/1
- prac_generic
    - トレイトが分からないと分からん
- トレイト
    - 他の言語でいうインターフェイス
    - python だとクラスみたいな？ひな形的なやつかも